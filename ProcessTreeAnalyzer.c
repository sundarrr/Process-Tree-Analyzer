    #include <stdio.h>    #include <stdlib.h>    #include <unistd.h>    #include <sys/types.h>    #include <string.h>    #include <dirent.h>    #include <signal.h>    #include <fcntl.h>    // To check if the process in there    int process_exists(pid_t pid) {        if (kill(pid, 0) == 0) {            return 1; // Process exists        } else {            return 0; // Process doesn't exist        }    }    // To get the parent PID of a process    pid_t get_parent_pid(pid_t pid) {        char stat_path[64];        snprintf(stat_path, sizeof(stat_path), "/proc/%d/stat", pid);        FILE *stat_file = fopen(stat_path, "r"); //Open the process status file        if (stat_file == NULL) {            perror("Error opening stat file");            exit(EXIT_FAILURE);        }        pid_t ppid;        if (fscanf(stat_file, "%*d %*s %*c %d", &ppid) != 1) { //Read the parent PID from stat file            perror("Error reading parent PID");            exit(EXIT_FAILURE);        }        fclose(stat_file); //close the file        return ppid;    }    // Function to check if a process is in the process tree rooted at root_process    int isInTree(pid_t process, pid_t root_process) {        pid_t current_pid = process;        while (current_pid != root_process) { //Traverse the process tree till we reach root process            if (current_pid == 1) {                return 0; // If Process is not in the tree            }            current_pid = get_parent_pid(current_pid);        }        return 1; // If Process is in the tree    }    // Function to check if a process is in a defunct state    int isZombieProcess(pid_t pid) {        char status_path[64];        snprintf(status_path, sizeof(status_path), "/proc/%d/status", pid); //Path to process status file in proc dictionary        FILE *file = fopen(status_path, "r"); //Open the process status file        if (file == NULL) {            perror("Error opening status file");            exit(EXIT_FAILURE);        }        char line[256];        while (fgets(line, sizeof(line), file)) {            if (strncmp(line, "State:", 6) == 0) {                fclose(file);                // Check if the process is in a defunct state                return strstr(line, "Z") != NULL;            }        }        fclose(file); //Close the file        return 0; // Default: not defunct    }    // Function to recursively list all PIDs under the given process ID    void listAllPIDs(pid_t process_id, FILE* tempFile) {        fprintf(tempFile, "%d\n", process_id); // Write the current process ID to the temporary file        DIR *dir; //Open the task direcory for the process        struct dirent *entry;        char path[128];        snprintf(path, sizeof(path), "/proc/%d/task", process_id);        dir = opendir(path);        if (dir == NULL) {            perror("Error opening task directory");            return;        }        while ((entry = readdir(dir)) != NULL) { // Traverse all entries in the task directory            if (entry->d_type == DT_DIR && atoi(entry->d_name) > 0) { // Check if the entry is a directory and represents a valid PID                listAllPIDs(atoi(entry->d_name), tempFile); // Recursively list all PIDs under the current entry            }        }        closedir(dir); //Close the directory    }    // Function to kill a process by its PIDint terminateProcess(pid_t pid) {    if (kill(pid, SIGTERM) == 0) { // Sending the SIGTERM signal to the process        printf("Terminated process with PID %d successfully.\n", pid);        return 0;    } else {        perror("Error terminating the process");        return 1;    }}    // Function to suspend the process    // Function to suspend a process by sending the SIGSTOP signalint suspendProcess(pid_t pid) {    // Sending the SIGSTOP signal to the process    if (kill(pid, SIGSTOP) == -1) {        perror("Error suspending the process");        return -1;    }    printf("Paused process with ID %d.\n", pid);    return 0;}    // Function to list sibling processes    void listSiblingProcesses(pid_t processID) {        char path[128];        snprintf(path, sizeof(path), "/proc/%d/status", processID); //Path to status file of current process        FILE *file = fopen(path, "r");        if (file == NULL) {            perror("Error opening status file");            return;        }        pid_t parentPID = -1;        // Read the parent PID from the status file        char line[256];        while (fgets(line, sizeof(line), file)) { //Read the parent PID from status file            if (strncmp(line, "PPid:", 5) == 0) {                sscanf(line + 5, "%d", &parentPID);                break;            }        }        fclose(file); //Close the file        if (parentPID == -1) {            fprintf(stderr, "Unable to determine the parent process ID.\n");            return;        }        // Now, list processes that have the same parent PID        DIR *dir = opendir("/proc");        if (dir == NULL) {            perror("Error opening /proc directory");            return;        }        printf("Siblings of %d:\n", processID);        struct dirent *entry;        while ((entry = readdir(dir)) != NULL) { // Traverse all entries in the /proc directory            if (entry->d_type == DT_DIR) { //check if entry is dictionary                pid_t pid = atoi(entry->d_name);                if (pid != 0 && pid != processID) {                    // Check if the process has the same parent PID                    snprintf(path, sizeof(path), "/proc/%d/status", pid);                    FILE *statusFile = fopen(path, "r");                    if (statusFile != NULL) {                        pid_t checkParentPID = -1;                        while (fgets(line, sizeof(line), statusFile)) { // Read the parent PID from the status file                            if (strncmp(line, "PPid:", 5) == 0) {                                sscanf(line + 5, "%d", &checkParentPID);                                break;                            }                        }                        fclose(statusFile); //Close the status file                        if (checkParentPID == parentPID) {                            printf("The Sibling is: %d\n", pid);                        }                     }                }            }        }    }    // Function to check the status of a process in the process tree   // Function to check the status of a process in the process tree void check_process_status(pid_t process_id, pid_t root_process) {    if (!process_exists(process_id)) {        printf("Process ID %d doesn't exist\n", process_id);        return;    }    pid_t current_pid = process_id;    pid_t parent_pid;    while (current_pid != root_process) {        if (!process_exists(current_pid)) {            printf("Process ID %d doesn't belong to the process tree rooted at %d\n", process_id, root_process);            return;        }        parent_pid = get_parent_pid(current_pid);        if (parent_pid == 1) {            printf("Process ID %d doesn't belong to the process tree rooted at %d\n", process_id, root_process);            return;        }        current_pid = parent_pid;    }    if (isZombieProcess(process_id)) {        printf("Process ID %d is defunct (zombie)\n", process_id);    } else {        printf("Process ID %d is not defunct\n", process_id);    }}    // Function to enumerate immediate children of a given processvoid enumerateImmediateChildren(int parent) {    char command[256];    FILE *stream;    // Ensure that the parent process exists in the process tree    if (!isInTree(parent, parent))         return; // Exit if the parent doesn't exist    // Execute the pgrep command to list immediate children of the parent process    sprintf(command, "pgrep -P %d", parent);    stream = popen(command, "r");        if (!stream) {        printf("Error while enumerating immediate children\n");        exit(EXIT_FAILURE);    }    int found = 0;    printf("Immediate descendants of %d:\n", parent);    // Read the output of the pgrep command    while (fgets(command, sizeof(command), stream)) {        int childPID;        if (sscanf(command, "%d", &childPID) == 1) {            printf("%d\n", childPID);            found = 1;        }    }    // If no immediate children are found, display a message    if (!found)         printf("No immediate descendants\n");        pclose(stream); // Close the command stream}       // Function to display all defunct (zombie) descendants of a given processvoid zombieprocess(int process_id) {    char tempFileName[] = "/tmp/pidsXXXXXX";    int tempFileDescriptor = mkstemp(tempFileName);    if (tempFileDescriptor == -1) {        perror("Creating temporary file failed");        exit(EXIT_FAILURE);    }    FILE* tempFile = fdopen(tempFileDescriptor, "w+");    if (tempFile == NULL) {        perror("Opening temporary file failed");        close(tempFileDescriptor); // Ensure the file descriptor is closed        exit(EXIT_FAILURE);    }    // Recursively list all PIDs under the given process ID    listAllPIDs(process_id, tempFile);    fflush(tempFile); // Flush and seek to the beginning of the temporary file    fseek(tempFile, 0, SEEK_SET);    printf("Defunct (zombie) descendants of %d:\n", process_id);    int found = 0, pid;    while (fscanf(tempFile, "%d", &pid) == 1) { // Read PIDs from the temporary file and check if they are defunct        if (pid != process_id && isZombieProcess(pid)) {            printf("%d\n", pid);            found = 1;        }    }    // If no defunct descendants found, print a message    if (!found) {        printf("No defunct descendant processes found.\n");    }    fclose(tempFile); // Close the temporary file    remove(tempFileName); // Remove the temp file}    // Function to list all grandchildren of a processvoid enumerateGrandchildren(int parent) {    char command[256];    FILE *stream;    // Ensure that the parent process exists in the process tree    if (!isInTree(parent, parent))         return; // Exit if the parent doesn't exist    // Execute the pgrep command to list immediate children of the parent process    sprintf(command, "pgrep -P %d", parent);    stream = popen(command, "r");    if (!stream) {        printf("Error while enumerating grandchildren\n");        exit(EXIT_FAILURE);    }    int found = 0;    printf("Grandchildren of %d:\n", parent);    // Read the output of the pgrep command    while (fgets(command, sizeof(command), stream)) {        int childPID;        if (sscanf(command, "%d", &childPID) == 1) {            FILE *grandchildStream = popen((sprintf(command, "pgrep -P %d", childPID), command), "r");            if (grandchildStream) {                // Read the output of the pgrep command for grandchildren                while (fgets(command, sizeof(command), grandchildStream)) {                    int grandchildPID;                    if (sscanf(command, "%d", &grandchildPID) == 1) {                        printf("%d\n", grandchildPID);                        found = 1;                    }                }                pclose(grandchildStream); // Close the grandchild process listing stream            }        }    }    // If no grandchildren are found, display a message    if (!found)         printf("No grandchildren\n");        pclose(stream);}    int main(int argc, char *argv[]) {        pid_t process_id = atoi(argv[1]);        pid_t root_process_id = atoi(argv[2]);        // Check for the presence of additional command-line arguments        if (argc == 4) {            char *option = argv[3];            if (strcmp(option, "-rp") == 0) {                return terminateProcess(process_id);            } else if (strcmp(option, "-pr") == 0) {                return terminateProcess(root_process_id);            } else if (strcmp(option, "-xt") == 0) {                return suspendProcess(process_id);            } else if (strcmp(option, "-xs") == 0) {                listSiblingProcesses(process_id);            } else if (strcmp(option, "-zs") == 0) {                check_process_status(process_id, root_process_id);            } else if (strcmp(option, "-xd") == 0) {                enumerateImmediateChildren(process_id);            } else if (strcmp(option, "-xz") == 0) {                zombieprocess(process_id);            } else if (strcmp(option, "-xg") == 0) {                enumerateGrandchildren(process_id);            }        }        return 0;    }